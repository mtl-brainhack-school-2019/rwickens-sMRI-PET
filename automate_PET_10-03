#!/usr/bin/python

# ^ won't be needed with _install_PET.py file 



"""-----------INFORMATION FOR USER: 

# PET file must have multiple frames. MRI file has already been run on CIVET

# You can adjust defaults on the configuration json file.

# Example bash input: python automate_PET_10-01.py 102.0 8.4 "ROYM"

# Weight and dose inputted are float (must have a decimal). (Check if this is even necessary)

# Blur will be done at 4, 6, and 8 mm. 

# Assumes you are in a directory containing patients' folders. Keep the py script, installer script, and json file in the larger directory.

"""



#outputPETpath.unlink()



from pathlib import Path

from copy import deepcopy

import argparse

import subprocess

import os

from importlib import import_module

import json

import glob



newest_minctools = max(glob.glob("/opt/minc/1.9.*"))

MINC_DIR = Path(newest_minctools)

DEFAULT_MINC_CONFIG = MINC_DIR / 'minc-toolkit-config.sh'

DEFAULT_MINC_BEST_LIN = MINC_DIR.joinpath('bin/bestlinreg_s')



parser = argparse.ArgumentParser('image processing inputs')

parser.add_argument('weight', type=float)

parser.add_argument('dose', type=float)

parser.add_argument('folder')    



args = parser.parse_args()



# ISSUE 1 : getting weird outputs from os.path.basename/dirname

def splice(path: Path, modifier) -> Path:

    """

    #path = Path(path)

    dir_name = os.path.dirname

    base_name = os.path.basename

    if dir_name.count(".") > 1:

        print("Somewhere in your path, your folders have a '.' that should be removed")

    if base_name.count(".") > 1:

        base_name.replace(".","")

    path = base_name.append(dir_name)

    path = Path(path)

    """

    return path.parent.joinpath(path.stem + modifier).with_suffix(path.suffix)



def main(weight, dose, folder):



    workdir = Path(os.getcwd())

    print("workindir is")

    print(workdir)

    patient_dir = Path(os.getcwd()).joinpath(folder)

    print("patientdir is")

    print(patient_dir)

    if patient_dir.exists() == False:  

        print("problem with locating patient directory")

        raise SystemExit()



    json_path = Path(os.getcwd(), 'config.json')



    if json_path.exists():

        config = json.load(json_path.open())

        PETsuffix = config['PET_SUFFIX']

        MRIsuffix = config['MRI_SUFFIX']

        talsuffix = config['TAL_SUFFIX']

        ITsuffix = config['IT_SUFFIX']

        MNItemplatepath = config['MNI_TEMPLATE_PATH']

        mask_or_atlas_path = config['MASK_OR_ATLAS_PATH']

        maskbinvalue = config['MASK_BIN_VALUE']

        mincconfigpath = config['MINC_CONFIG_PATH']

        mincbestlinregpath = config['MINC_BEST_LIN_REG_PATH']

    else:

        PETsuffix = "4D_MC01.mnc" 

        MRIsuffix = "_t1.mnc"   

        talsuffix = "t1_tal.xfm"

        ITsuffix = "_It.xfm"

        MNItemplatepath = workdir / "mni_icbm152_t1_tal_nlin_sym_09c.mnc"

        mask_or_atlas_path = workdir / "WM_0.99_new.mnc"

        maskbinvalue = 1

        mincconfigpath = DEFAULT_MINC_CONFIG

        mincbestlinregpath = DEFAULT_MINC_BEST_LIN



    PETpath = []

    MRIpath = []

    talpath = []

    ITpath = []



    for root, dirs, files in os.walk(patient_dir): 

        #for root, dirs, files in os.walk(patient_dir): #less possibility for error this way...

        PETpath = glob.glob("**/*" + PETsuffix)

        MRIpath = glob.glob("**/*"+MRIsuffix)

        talpath = glob.glob("**/*"+talsuffix)

        ITpath = glob.glob("**/*"+ITsuffix)

    print(PETpath, MRIpath, talpath, ITpath)



    if len(PETpath) == 1:

        pass

    elif len(PETpath) > 1: 

        print("Multiple PET files ending in", PETsuffix, ". Check that there is only one patient's files in this patient folder.")

        raise SystemExit(0)

    else:

        print("No file found. Please check that your PETfile ends in", PETsuffix)

        raise SystemExit(0)

    if len(MRIpath) == 1:

        pass

    elif len(MRIpath) > 1: 

        print("Multiple PET files ending in", MRIsuffix, "check that the non-CIVET MRI file is not in this folder, and ensure that only one patient's files in this patient folder!")

        raise SystemExit(0)

    else:

        print("No file found. Please check that your PETfile ends in", MRIsuffix)

        raise SystemExit(0)

    if len(PETpath) == 1:

        pass

    elif len(talpath) > 1: 

        print("Multiple PET files ending in", talsuffix, "check that there is only one patient's files in this patient folder!")

        raise SystemExit(0)

    else:

        print("No file found. Please check that your PETfile ends in", talsuffix)

        raise SystemExit(0)

    if len(ITpath) == 1:

        pass

    elif len(ITpath) > 1: 

        print("Multiple PET files ending in", ITsuffix, "check that there is only one patient's files in this patient folder!")

        raise SystemExit(0)

    else:

        print("No file found. Please check that your PETfile ends in", ITsuffix)

        raise SystemExit(0)



    PETpath = Path(PETpath[0])

    MRIpath = Path(MRIpath[0])

    talpath = Path(talpath[0])

    ITpath= Path(ITpath[0])



    with open('output' + "hello" + '.txt', 'w') as f: # to-do: write to subject folder

        def bash_command(*args):

            bash_output = subprocess.check_output([str(c) for c in args])

            print(bash_output)

            #str(bash_output) #bc: error "write() argument must be str, not bytes"

            #f.write(bash_output) 

            #check_output might stop when warnings are given? 



        def bash_command_shell(cmd):

            subprocess.run(cmd, shell=True, executable='/bin/bash')





        mylist = []

        xfmlist = []

        mylist.append(PETpath)

        outputPETpath = mylist[-1]

        outputPETpath_xfm = outputPETpath.with_suffix('.xfm')

        xfmlist.append(outputPETpath_xfm)



        """

        (Not needed unless dealing with .v files - such as with FDG)

        # 1. Change the file extension from .v to .mnc

        outputPETpath = PETpath.with_suffix('.mnc')

        mylist.append(outputPETpath)

        bash_command('ecattominc', '-short', PETpath, outputPETpath)

        """

        

        # 2. Average the PET frames

        outputPETpath = splice(outputPETpath, '_avg')

        mylist.append(outputPETpath)

        bash_command('mincaverage', mylist[-2], outputPETpath, '-avgdim', 'time')



        # 3. Take the SUV

        constant = dose * 1000 / weight

        print("dose * 1000 / weight = " + str(constant))

        outputPETpath = splice(outputPETpath, "_suv")

        mylist.append(outputPETpath)

        bash_command('mincmath', '-div', mylist[-2], '-const', constant, outputPETpath)



        # 4. Automatic coregistration of subject PET to subject MRI to obtain .xfm files

        outputPETpath_xfm = splice(outputPETpath_xfm, "_autoreg")

        xfmlist.append(outputPETpath_xfm)

        outputPETpath = splice(outputPETpath, "_autoreg")

        mylist.append(outputPETpath)

        bash_command_shell("source " + mincconfigpath)

        #bash_command('source', mincconfigpath)

        bash_command(mincbestlinregpath, '-nmi', '-lsq6', mylist[-2], MRIpath, outputPETpath_xfm, outputPETpath)



        # 5. Linear and non-linear transformations to put the PET file into MNI space (toST = to Standard Template)

        outputPETpath_xfm = splice(outputPETpath_xfm, '_toST').with_suffix('.xfm')

        xfmlist.append(outputPETpath_xfm)

        bash_command('xfmconcat', xfmlist[-2], talpath, ITpath, outputPETpath_xfm)

        outputPETpath = splice(outputPETpath, "_ST")

        mylist.append(outputPETpath)

        bash_command('mincresample', mylist[-2], '-like', MNItemplatepath, '-transform', outputPETpath_xfm,

                     outputPETpath)



        # 6A. Take the SUVR in MNIspace

        mylist_patient = deepcopy(mylist)  # Divergence in image processing (template space versus patient space)

        maskbinvalue = str(maskbinvalue)

        mask_or_atlas_path = str(mask_or_atlas_path)

        mask_SUV = subprocess.check_output(

            ['mincstats', '-mask', mask_or_atlas_path, '-mask_binvalue', maskbinvalue, outputPETpath, '-mean'])

        print("check output of mask_SUV gives", mask_SUV)    

        # make multiple maskbinvalues possible here (csv); set shell=True and come up with method

        outputPETpath = splice(outputPETpath, '_SUVR')

        mylist.append(outputPETpath)

        bash_command('mincmath', '-div', '-const', mask_SUV, mylist[-2], outputPETpath)



        # 6B - Take the SUVR in patient space

        PET_subjectmask = str(folder) + "_subjectmask.mnc"

        bash_command('mincresample', '–like', mylist[-3], '–nearest', '–transform', outputPETpath_xfm,

                     '–invert_transformation', mask_or_atlas_path, PET_subjectmask)

        outputPETpath_patient = splice(outputPETpath, '_patient_SUVR')

        mylist_patient.append(outputPETpath_patient)

        mask_SUV_patient = subprocess.run(

            ['mincstats', '–mask', PET_subjectmask, '–mask_binvalue', mylist[-3], mylist_patient[-2], '–mean'],

            capture_output=True, check=True)

        bash_command('mincmath', '-div', '-const', mask_SUV_patient, mylist_patient[-2], outputPETpath_patient)



        # 7A. Blur PET in 4, 6, and 8mm

        blurlist = [4, 6, 8]

        templist = []

        for i in blurlist:

            blur_word = "_blur_" + str(i)

            outputPETpath = splice(outputPETpath, blur_word)

            templist.append(outputPETpath)

            bash_command('mincblur', '-fwhm', i, mylist[-2], outputPETpath)

        mylist.append("templist")

            #Note: Camille says minc automatically adds mnc extension here; should have extension removed from outputBlurPath



        # 7B. Blur PET in 4, 6, and 8 mm for patient space image

        blurlist = [4, 6, 8]

        templist_patient = []

        for i in blurlist: 

            blur_word = "_blur_" + str(i)

            outputPETpath_patient = splice(outputPETpath_patient, blur_word)

            templist.append(outputPETpath_patient)

            bash_command('mincblur', '-fwhm', i, mylist[-2], outputPETpath_patient)

        mylist_patient.append("templist_patient")

            #Note: Camille says minc automatically adds mnc extension here; should have extension removed from outputBlurPath



        # 8. Finished. Show the subject's PET file on MNI template

        bash_command('register', outputPETpath, MNItemplatepath)



        # 9. Black border for MNI mask 



main(**vars(args))

